<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BAU</title>

	<style>
		body {
			margin: 0;
			overflow: hidden;
			background: #131313;
		}
	</style>
</head>
<body>
</body>
<script type="module">
	let bau = await bauLoader;

	const { Ticker, Render, Vec2, Engine, BodyOptions } = bau;
	window.Vec2 = Vec2;
	window.bau = bau;
	window.BodyOptions = BodyOptions;
	
	let engine = new Engine();
	let render = new Render();
	

	let ticker = new Ticker();
	window.runEngine = true;
	ticker.on("physicsTick", () => {
		if (window.runEngine) {
			engine.physics_update(Math.min(ticker.Performance.delta, 0.2) || 1 / 60);
			render.render(engine);
		}
	});
	
	function basic() {
		let bodyA = engine.body_create_rect(100, 100, new Vec2(300, 300), {
			friction: 0.5,
			restitution: 0.5,
			mass: 2,
		});
		engine.world_add_body(bodyA);
		engine.body_set_angle(bodyA, 0.4);
		let bodyB = engine.body_create_circle(50, new Vec2(300, 170), {
			friction: 0.5,
			restitution: 0.5,
		});
		// engine.world_add_body(bodyB);
		
		window.bodyA = bodyA;
		window.bodyB = bodyB;
	}
	function stack() {
		let width =  1;
		let height = 60;
		let size = 15;

		for (let x = 0; x < width; ++x) {
			for (let y = 0; y < height; ++y) {
				let body = engine.body_create_rect(size, size, new Vec2(700 + size * (width/2 - x), 500 - y * size), {
					friction: 0.5,
					restitution: 0.2,
				});
				engine.world_add_body(body);
			}
		}
	}
	function multistack() {
		let width =  20;
		let height = 20;
		let size = 50;

		let offsetX = 500;
		let offsetY = 700;

		for (let x = 0; x < width; ++x) {
			for (let y = 0; y < height; ++y) {
				let body = engine.body_create_rect(size, size, new Vec2(offsetX + size * (width/2 - x), offsetY - y * size), {
					friction: 0.5,
					restitution: 0.2,
				});
				engine.world_add_body(body);
			}
		}
	}
	
	multistack();

	let floor = engine.body_create_rect(6000, 100, new Vec2(700, 1000), {
		is_static: true,
		mass: 10,
	});
	engine.world_add_body(floor);

	let mouseBody = engine.body_create_circle(5, new Vec2(10, 10), {
		is_static: false,
		mass: 0.03,
	});
	engine.world_add_body(mouseBody);

	window.engine = engine;
	window.mouseBody = mouseBody;

	let screenMousePosition = new Vec2(0, 0);
	let mousePosition = new Vec2(0, 0);
	function toWorldSpace(position) {
		let newPos = { x: 0, y: 0 };
		newPos.x = (position.x / render.scale - render.position.x);
		newPos.y = (position.y / render.scale - render.position.y);
		return newPos;
	}
	window.addEventListener("mousemove", event => {
		let { clientX: mouseX, clientY: mouseY } = event;

		screenMousePosition.x = mouseX;
		screenMousePosition.y = mouseY;

		let worldSpaceMouse = toWorldSpace(screenMousePosition);
		mousePosition.x = worldSpaceMouse.x;
		mousePosition.y = worldSpaceMouse.y;
	});
	ticker.on("physicsTick", () => {
		if (window.runEngine) {
			let curPos = engine.body_get_position(mouseBody);
			let velScale = 300;
			let velocity = { x: mousePosition.x - curPos.x, y: mousePosition.y - curPos.y };
			if (velocity.x ** 2 + velocity.y ** 2 < 200) {
				velScale *= (velocity.x ** 2 + velocity.y ** 2) / 200
			}
			velocity.x = Math.abs(velocity.x) ** 0.5 * Math.sign(velocity.x) * velScale;
			velocity.y = Math.abs(velocity.y) ** 0.5 * Math.sign(velocity.y) * velScale;
			engine.body_set_velocity(mouseBody, new Vec2(velocity.x, velocity.y));
			engine.body_set_angle(mouseBody, 0);
		}
	});

	window.addEventListener("mouseover", event => {
		let { clientX: mouseX, clientY: mouseY } = event;

		screenMousePosition.x = mouseX;
		screenMousePosition.y = mouseY;

		let worldSpaceMouse = toWorldSpace(screenMousePosition);
		mousePosition.x = worldSpaceMouse.x;
		mousePosition.y = worldSpaceMouse.y;
		engine.body_set_position(mouseBody, new Vec2(mousePosition.x, mousePosition.y));
	});
	window.addEventListener("mousedown", event => {
		if (event.button == 1 || event.button == 2) {
			let lastPos = { x: event.clientX, y: event.clientY };

			function move(event) {
				let curPos = { x: event.clientX, y: event.clientY };
				render.position.x += (curPos.x - lastPos.x) / render.scale;
				render.position.y += (curPos.y - lastPos.y) / render.scale;
				lastPos = curPos;
			}
			function cancel() {
				if (event.button == 1 || event.button == 2) {
					window.removeEventListener("mousemove", move);
					window.removeEventListener("mouseup", cancel);
				}
			}
			window.addEventListener("mousemove", move);
			window.addEventListener("mouseup", cancel);
		}
	});
	window.addEventListener("wheel", event => {
		let dy = event.deltaY;
		let scaleFactor = (1 - (Math.abs(dy) ** 0.5 / 200) * Math.sign(dy)) ** 2;
		render.scale *= scaleFactor;

		let newMousePos = toWorldSpace(screenMousePosition);
		render.position.x += (newMousePos.x - mousePosition.x);
		render.position.y += (newMousePos.y - mousePosition.y);
	});
</script>
</html>